/*
Copyright 2020 The arhat.dev Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

syntax = "proto3";

// +build !rt_none
package aranya;

option go_package = "arhat.dev/aranya-proto/aranyagopb";


message AuthConfig {
    string username = 1;
    string password = 2;

    string auth = 3;
    string server_address = 4;
    // IdentityToken is used to authenticate the user and get
    // an access token for the registry.
    string identity_token = 5;
    // RegistryToken is a bearer token to be sent to a registry
    string registry_token = 6;
    string email = 7;
}

enum ImagePullPolicy {
    IMAGE_PULL_ALWAYS = 0;
    IMAGE_PULL_IF_NOT_PRESENT = 1;
    IMAGE_PULL_NEVER = 2;
}

message ImagePullConfig {
    // image pull secrets
    AuthConfig auth_config = 1;
    // pull policy
    ImagePullPolicy pull_policy = 2;
}

message ImageEnsureCmd {
    map<string, ImagePullConfig> images = 1;
}

message NamedData {
    map<string, bytes> data_map = 1;
}

message ContainerPort {
    string protocol = 1;
    int32 container_port = 2;
    int32 host_port = 3;
    string host_ip = 4;
}

message SELinuxOptions {
    string type = 1;
    string level = 2;
    string role = 3;
    string user = 4;
}

message ContainerSecurityOptions {
    enum ProcMountKind {
        PROC_MOUNT_DEFAULT = 0;
        PROC_MOUNT_UNMASKED = 1;
    }

    bool privileged = 1;
    bool allow_new_privileges = 2;
    bool non_root = 3;
    bool read_only_rootfs = 4;

    int64 user = 5;
    int64 group = 6;

    repeated string caps_add = 7;
    repeated string caps_drop = 8;

    ProcMountKind proc_mount_kind = 9;

    SELinuxOptions selinux_options = 10;
}

message MountOptions {
    string mount_path = 1;
    string sub_path = 2;
    bool read_only = 3;
    // device type
    string type = 4;
    repeated string options = 5;
    uint32 file_mode = 6;

    // mount this volume use cluster CSI
    bool remote = 7;
}

message KeyValuePair {
    string key = 1;
    string value = 2;
}

message ActionMethod {
    message ActionExec {
        repeated string command = 1;
    }

    message ActionHTTP {
        string method = 1;
        string url = 2;
        repeated KeyValuePair headers = 3;
    }

    message ActionSocket {
        string url = 1;
    }

    oneof action {
        ActionExec exec = 1;
        ActionHTTP http = 2;
        ActionSocket socket = 3;
    };
}

message Probe {
    ActionMethod method = 1;

    int64 initial_delay = 2;
    int64 probe_timeout = 3;
    int64 probe_interval = 4;

    int32 success_threshold = 5;
    int32 failure_threshold = 6;
}

message ContainerSpec {
    string name = 2;
    // container image name to pull
    string image = 1;

    // Command (ENTRYPOINT in Dockerfile)
    repeated string command = 3;
    // Args (CMD in Dockerfile)
    repeated string args = 4;

    string working_dir = 5;
    bool stdin = 6;
    bool stdin_once = 7;
    bool tty = 8;

    // Contaienr environment variables
    //
    // key: env key
    // value: env value
    map<string, string> envs = 11;

    // Container voulme or device mounts
    //
    // key: volume or device name
    // value: mount options
    map<string, MountOptions> mounts = 12;

    Probe readiness_check = 13;
    Probe liveness_check = 14;

    //
    // resolved security opts in pod
    //
    ContainerSecurityOptions security = 21;

    //
    // Container hooks
    //
    ActionMethod hook_post_start = 31;
}

enum RestartPolicy {
    RESTART_ALWAYS = 0;
    RESTART_ON_FAILURE = 1;
    RESTART_NEVER = 2;
}

message Bandwidth {
    // unit: bits/s
    int32 ingress_rate = 1;
    int32 egress_rate = 2;

    // unit: bits
    int32 ingress_burst = 3;
    int32 egress_burst = 4;
}

message PodNetworkOptions {
    string cidr_ipv4 = 1;
    string cidr_ipv6 = 2;

    Bandwidth bandwidth = 3;
}

message PodEnsureCmd {
    // kubernetes metadata
    string pod_uid = 1;
    string namespace = 2;
    string name = 3;

    RestartPolicy restart_policy = 4;

    //
    // Relationships to host namespaces
    //
    bool host_ipc = 5;
    bool host_network = 6;
    bool host_pid = 7;
    // share pid namespace between containers in the same pod
    bool share_pid = 8;
    // wait unitl all containers defined in this cmd exited with no error
    bool wait = 9;
    // custom hostname to override container id as hostname
    string hostname = 10;

    repeated ContainerSpec containers = 11;

    // Container ports is processed when creating the pause container
    //
    // key: port name
    //          the port name is in the format of `{container}/{port_name}`
    //          if the port name is missing in the corev1.Container,
    //          it's index number in the containers list will be used as {port_name}
    // value: port map and spec
    //          currently only ports with `host_port` specified will be exposed
    map<string, ContainerPort> ports = 13;

    //
    // Network options
    //
    repeated string name_servers = 14;
    repeated string search_domains = 15;
    // /etc/hosts entries
    //
    // key: hostname
    // value: ip
    map<string, string> hosts = 16;
    repeated string dns_options = 17;
    PodNetworkOptions network = 18;

    //
    // Volumes and devices (in early days, they are the same)
    //

    // Volumes and devices' host path
    //
    // key: volume or device name
    // value: host path
    map<string, string> host_paths = 21;

    // Data to populate files in container
    //
    // key: volume name
    // value: data from {ConfigMap, Secret}
    map<string, NamedData> volume_data = 22;

    map<string, string> labels = 23;

    // Security options
    map<string, string> sysctls = 31;
}

message PodDeleteCmd {
    // pod to perform delete operation
    string pod_uid = 1;
    // containers to delete, if not specified, delete this pod
    repeated string containers = 2;

    // pod deletion grace time
    int64 grace_time = 10;
    map<string, ActionMethod> hook_pre_stop = 11;
}

message PodListCmd {
    // pod namespace
    string namespace = 1;
    // pod name
    string name = 2;
    // show all pods available
    bool all = 3;
}
